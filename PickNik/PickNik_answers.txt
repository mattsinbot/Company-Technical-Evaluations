9. a) Jacobian matrix is a map of joint rates to end effector velocity. More specifically for N-DoF manipulator jacobian maps R^N -> R^6.
   b) Inverse kinematics is a map from end effector space to joint space of a manipulator. There are two common approaches of performing inverse kinematics. One is pseudo-inverse of jacobian based method, also known as velocity based IK methods. Another one is geometric inverse kinematics based method where robot geometric structure is exploited to solve joint solutions.
   c) trajectory of a manipulator is a time stamped joint angles and joint rates with accleration information. Manipulatorsa re controlled in joint space whereas it has t perform task in end effector space. Sice we control a manipulator in joint space it is advantageous to represent trajectory in joint space. If trajectory is defined in task space then at each point one need to solve inverse kinematics problem at the expense of computational power and time. Also the state of the art sampling based motion planners works in joint space. However there are situations, especially when end effector motion is constrained, for instance transfering a glass of water, describing trajectory in task space is useful.


8. a) There are 3 most common ways to represent rotations. 1. Rotation matrix (6 independent parameters) 2. Unit Quaternion (3 independent and 1 constrained parameters) 3. Roll pitch yaw (3 independent parameters). Although roll pich yaw has only 3 independent parameters, but this represetation is not singularity free (the Gimbol lock situation). Unit quaternion representation is the most effective representation of rotation and always singularity free. Rotation matrix is also useful to represent transform of frames using DH parameters.
   b) Rotation matrices are elements of SO(3), special orthogonal group. Each column of it has unit norm and orthogonal to each other. This means rotation matrices are orthonomal. Inverse of any orthonrmal matrix is just the transpose of it.
   c) The main advantage of using DH transform as opposed to full transform is the reduction in number of parameters required to represent transformation between two consecutive frames. DH parameter based transformation representation needs 4 parameters whereas full transformations need 7 (4 for rotation and 3 for position) parameters.

4. It tries to access data after the destructor has been called, hence throws memory error. 

3. pointer to a stack variable is an illigal operation. As the function returns its stack space is invalidated, hence the pointer. We need to allocated dynamic memory as following,

int* area(int length,int width){
    int * area = malloc(sizeof(int));
    *area = length*width;
    return area;
}

int main() {
    printf("area=%i\n",*area(5,6));
}

2. Output of this program is AABCBC. At first when a[2] is instantiated it called A() (the default constructor) twice and printed "AA" and creates an array of type A. Then for each element of "for (auto x:a)" will print one "B" and then when method f() is called it print "C" each time.  


1. a) Output:0. Because: The string 0x16 is a integer literal indicating the value 22, which represent by 16 in hexadecimal. So they are not same.
   b) Returns the number of elements in the container.
   c) Answer : 16. It is a bit shift operation. For every 1 on the right, you can think of yourself as multiplying the value on the left by 2. Example: 2<<1=4. This is much more efficient than doing 1*2.
   d) Output: 0. Because 2<1 is a less than operator.
   e) Output:2. (11/4) = division operator.


5. #include <iostream>
using namespace std;


template<typename T> class Logger
{
    public:
        Logger (const T& input);
        void print() const;
    private:
        T data;
};


// Part B
void Logger<int>::print() {
    /* where data is a std vector and iterator of a vector is implemented*/
    for (auto itr=data.cbegin(); itr!=data.cend(); itr++) {
        std::cout << *itr << " ";
    }
}


// Part A
int main() {
    Logger<int>* myLogger(5);
    myLogger.print();

    return 0;
}

6A. 
#include <iostream>
using namespace std;

class Joint {
    public:
        Joint() : position(2.0) {}
        double getPosition() const {return position;}
    protected:
        double position;
};

class RevoluteJoint: public Joint {
    public:
        double squared() {return position*position;}
};

int main() {
    RevoluteJoint rj;
    std::cout << rj.squared() << std::endl;
    
    return 0;
}

6B.
#include <iostream>
using namespace std;

class Joint {
    public:
        Joint() : position(2.0) {}
        double getPosition() const {return position;}
    protected:
        double position;
};

class RevoluteJoint: public Joint {
    private:
        Joint jt;
    public:
        double squared() {return jt.getPosition()*jt.getPosition();}
};

int main() {
    RevoluteJoint rj;
    std::cout << rj.squared() << std::endl;
    
    return 0;
}

7.
#include <iostream>
using namespace std;

int main() {
    for (int i = 0; i!= 100; i ++) {
        if(i%3==0 && i%5==0) std::cout << i << ":" << "PickNik" << std::endl;
        else if(i%3==0) std::cout << i << ":" << "Pick" << std::endl;
        else if(i%5==0) std::cout << i << ":" << "Nik" << std::endl;
    }
    return 0;
}


6. 
